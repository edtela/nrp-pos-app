{"version":3,"sources":["../src/index.ts","../src/symbols.ts","../src/update.ts","../src/select.ts","../src/change-detection.ts"],"sourcesContent":["// Export symbols\nexport { ALL, WHERE, DEFAULT, CONTEXT, META } from './symbols.js';\n\n// Export types\nexport type {\n  Update,\n  UpdateResult,\n  UpdateResultMeta,\n  DataChange,\n  ChangeDetector,\n  ChangeDetectorFn,\n  Select,\n  SelectResult\n} from './types.js';\n\n// Export update, undo, and transaction functionality\nexport { update, undo, transaction } from './update.js';\n\n// Export select functionality\nexport { select } from './select.js';\n\n// Export change detection\nexport { hasChanges, anyChange, typeChange } from './change-detection.js';","// Define symbols for operations\nexport const ALL = Symbol(\"*\"); // Apply update to all properties\nexport const WHERE = Symbol(\"?\"); // Conditional filter for updates\nexport const DEFAULT = Symbol(\"{}\"); // Default value for null fields\nexport const CONTEXT = Symbol(\"$\"); // Context variables\nexport const META = Symbol(\"#\"); // Track structural changes (delete/replace) in DataChange","import { ALL, WHERE, DEFAULT, CONTEXT, META } from \"./symbols.js\";\nimport type { Update, UpdateResult } from \"./types.js\";\n\nexport function update<T extends object>(d: T, u?: Update<T>, c?: UpdateResult<T>): UpdateResult<T> | undefined {\n  return updateImpl(d, u, c);\n}\n\nexport function updateImpl(data: any, statement?: any, changes?: any, context?: any): any {\n  if (!statement) return undefined;\n\n  const { [WHERE]: where, [ALL]: all, [DEFAULT]: defaulT, [CONTEXT]: vars, ...rest } = statement;\n  const staticUpdate = rest;\n\n  if (vars) {\n    context = context ? { ...context, ...vars } : vars;\n  }\n\n  if (where && !where(data, context)) {\n    return changes;\n  }\n\n  if (all) {\n    for (const key in data) {\n      if (staticUpdate[key] === undefined) {\n        staticUpdate[key] = all;\n      }\n    }\n  }\n\n  function addValueChange(key: string, oldValue: any) {\n    const newValue = data[key];\n\n    if (oldValue != null && typeof oldValue === \"object\") {\n      //we need to undo changes that may have occured before setting it as original\n      const oldValueChanges = changes?.[key];\n      if (oldValueChanges) {\n        undoImpl(oldValue, oldValueChanges);\n      }\n    }\n\n    if (!changes) {\n      changes = {};\n    }\n    changes[key] = newValue;\n\n    const meta = changes[META];\n    if (meta) {\n      if (!meta[key]) {\n        // only record on first change, original value\n        meta[key] = { original: oldValue };\n      }\n    } else {\n      changes[META] = { [key]: { original: oldValue } };\n    }\n  }\n\n  function updateKey(key: string, oldValue: any, newValue: any, replace = false) {\n    if (oldValue === newValue) {\n      return;\n    }\n\n    if (!replace && newValue != null && typeof newValue === \"object\") {\n      if (oldValue == null || typeof oldValue !== \"object\") {\n        //check the where statement before throwing error\n        const where = newValue[WHERE];\n        if (where && !where(oldValue, context)) {\n          return;\n        }\n\n        const defaultValue = newValue[DEFAULT];\n        if (defaultValue) {\n          data[key] = structuredClone(defaultValue);\n          updateImpl(data[key], newValue, undefined, context);\n          addValueChange(key, oldValue);\n          return;\n        }\n\n        throw Error(`Can't partially update a non-object: ${key}`);\n      }\n\n      const change = updateImpl(oldValue, newValue, changes ? changes[key] : undefined, context);\n      if (change) {\n        if (changes) {\n          changes[key] = change;\n        } else {\n          changes = { [key]: change };\n        }\n      }\n      return;\n    }\n\n    // newValue null or not an object or full object, set directly\n    data[key] = newValue;\n    addValueChange(key, oldValue);\n  }\n\n  // Process each key in the expanded transform\n  for (const key in staticUpdate) {\n    let oldValue = data[key];\n\n    const operand = staticUpdate[key];\n    const staticOperand = typeof operand === \"function\" ? operand(oldValue, data, key, context) : operand;\n\n    if (Array.isArray(staticOperand)) {\n      if (staticOperand.length === 0) {\n        delete data[key];\n        addValueChange(key, oldValue);\n        continue;\n      }\n\n      if (staticOperand.length === 1) {\n        //structured clone can still fail for functions within operand\n        const newValue = typeof staticOperand[0] === \"function\" ? staticOperand[0] : structuredClone(staticOperand[0]);\n        updateKey(key, oldValue, newValue, true);\n      } else {\n        throw new Error(\"Multiple element arrays not allowed\"); //TODO collect warning\n      }\n    } else {\n      updateKey(key, oldValue, staticOperand);\n    }\n  }\n\n  return changes;\n}\n\nexport function undo<T extends object>(data: T, result: UpdateResult<T> | undefined) {\n  return undoImpl(data, result);\n}\n\nfunction undoImpl(data: any, result: any) {\n  if (data == null || typeof data !== \"object\" || result === undefined) {\n    return data;\n  }\n\n  const { [META]: meta, ...rest } = result;\n  for (const key in rest) {\n    const change = rest[key];\n    if (meta && key in meta) {\n      data[key] = meta[key].original;\n    } else {\n      undoImpl(data[key], change);\n    }\n  }\n}\n\nexport function transaction<T extends object>(data: T) {\n  let changes: UpdateResult<T> | undefined;\n\n  return {\n    update(stmt: Update<T>) {\n      changes = updateImpl(data, stmt, changes);\n      return this; // Allow chaining\n    },\n    commit: () => {\n      const v = changes;\n      changes = undefined;\n      return v;\n    },\n    revert: () => {\n      if (changes) {\n        undo(data, changes);\n      }\n      changes = undefined;\n    },\n  };\n}\n","import { ALL, WHERE } from \"./symbols.js\";\nimport { Select, SelectResult } from \"./types.js\";\n\nexport function select<T>(data: T, stmt: Select<T>): SelectResult<T> | undefined {\n  const result = selectImpl(data, stmt);\n  return result === NO_RESULT ? undefined : result;\n}\n\nconst NO_RESULT = Symbol();\nexport function selectImpl(data: any, stmt: Select<any>): SelectResult<any> | typeof NO_RESULT {\n  const { [ALL]: all, [WHERE]: where, ...rest } = stmt;\n\n  if (where && !where(data)) {\n    return NO_RESULT;\n  }\n\n  if (data == null || typeof data !== \"object\") {\n    return data;\n  }\n\n  let result: any = NO_RESULT;\n  function addToResult(key: string, keyStmt: any) {\n    if (Array.isArray(data)) {\n      const index = Number(key);\n      if (!Number.isInteger(index) || index < 0) {\n        return;\n      }\n    }\n\n    let keyValue = NO_RESULT;\n    if (keyStmt === true) {\n      keyValue = data[key];\n    } else if (keyStmt != null && typeof keyStmt === \"object\") {\n      keyValue = selectImpl(data[key], keyStmt);\n    }\n\n    if (keyValue !== NO_RESULT) {\n      if (result == NO_RESULT) {\n        result = Array.isArray(data) ? [] : {};\n      }\n      result[key] = keyValue;\n    }\n  }\n\n  if (all) {\n    for (const key in data) {\n      addToResult(key, all);\n    }\n  }\n\n  if (Array.isArray(result) && result.length > 0) {\n    result = result.filter((v, i) => i in result);\n  }\n\n  for (const key in rest) {\n    addToResult(key, rest[key]);\n  }\n\n  return result;\n}\n","import { ALL, META } from \"./symbols.js\";\nimport type { UpdateResult, ChangeDetector, ChangeDetectorFn } from \"./types.js\";\n\nexport function hasChanges<T extends object>(result: UpdateResult<T> | undefined, detector: ChangeDetector<T>) {\n  if (result === undefined) return false;\n\n  const { [ALL]: all, ...rest } = detector;\n  if (all) {\n    for (const key in result) {\n      if (!(key in rest)) {\n        (rest as any)[key] = all;\n      }\n    }\n  }\n\n  for (const key in rest) {\n    const keyDetector = (rest as any)[key];\n    if (typeof keyDetector === \"function\") {\n      if (keyDetector(key, result)) {\n        return true;\n      }\n    } else if (keyDetector !== undefined) {\n      if (hasChanges((result as any)[key], keyDetector)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport const anyChange: ChangeDetectorFn<any> = (key: string, r?: UpdateResult<any>) => {\n  return r !== undefined && key in r;\n};\n\nexport const typeChange: ChangeDetectorFn<any> = (key: string, r?: UpdateResult<any>) => {\n  const meta = r?.[META];\n  if (!meta || !(key in r) || !(key in meta)) return false;\n\n  const newValue = r[key];\n  const oldValue = meta[key]?.original;\n\n  if (newValue === null) return oldValue !== null;\n  if (oldValue === null) return newValue !== null;\n  return typeof newValue !== typeof oldValue;\n};"],"mappings":"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","names":["where"]}